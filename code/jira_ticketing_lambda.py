import boto3
import json
import requests
import re
from urllib.parse import unquote_plus

# Jira API configuration
JIRA_URL = ""
JIRA_API_ENDPOINT = f"{JIRA_URL}/rest/api/2/issue"
JIRA_PROJECT_KEY = ""
JIRA_USERNAME = ""
JIRA_API_TOKEN = ""

SEVERITY_TO_PRIORITY = {
"High": "High",
"Medium": "Medium",
"Low": "Low"
}

S3_BUCKET_NAME = ""

def lambda_handler(event, context):
try:
    # Extract bucket and file details
    s3_bucket = event['Records'][0]['s3']['bucket']['name']
    s3_key = unquote_plus(event['Records'][0]['s3']['object']['key'])
    
    if s3_bucket != S3_BUCKET_NAME:
        return {
            'statusCode': 200,
            'body': json.dumps(f'Incorrect bucket: {s3_bucket}')
        }
    
    if not s3_key.startswith('results/'):
        return {
            'statusCode': 200,
            'body': json.dumps('Skipping non-results file')
        }
    
    # Download the results file
    s3_client = boto3.client('s3')
    response = s3_client.get_object(Bucket=s3_bucket, Key=s3_key)
    results_content = json.loads(response['Body'].read().decode('utf-8'))
    
    # Extract violations from the results
    violations_text = results_content.get('violations', '')
    violations = parse_violations_table(violations_text)
    
    # Create Jira tickets
    tickets_created = []
    for violation in violations:
        ticket_key = create_jira_ticket(violation)
        if ticket_key:
            tickets_created.append({'ticket': ticket_key, 'violation': violation['log_line']})
    
    print(f"Created {len(tickets_created)} Jira tickets")
    
    return {
        'statusCode': 200,
        'body': json.dumps({
            'message': f'Successfully created {len(tickets_created)} Jira tickets',
            'tickets': tickets_created
        })
    }
except Exception as e:
    print(f"Error: {str(e)}")
    return {
        'statusCode': 500,
        'body': json.dumps(f'Error: {str(e)}')
    }

def parse_violations_table(violations_text):
"""
Parse the violations table from the JSON text.
The violations_text contains a markdown table within a larger text block.
"""
violations = []
lines = violations_text.split('\n')
table_start = False
table_header_found = False

for line in lines:
    # Look for the table header line
    if "| *Log Line* | *Rules Violated* |" in line:
        table_start = True
        table_header_found = True
        continue
    
    # Skip the separator line after the header
    if table_start and "| --- | --- |" in line:
        continue
        
    # Process table rows
    if table_start and line.startswith('|') and len(line.split('|')) >= 5:
        parts = line.split('|')
        if len(parts) >= 5:  # Ensure we have enough parts
            log_line = parts[1].strip().strip('"')
            rules_violated = parts[2].strip()
            description = parts[3].strip()
            severity = parts[4].strip()
            
            # Only add if we have valid data
            if log_line and rules_violated and description and severity:
                violations.append({
                    'log_line': log_line,
                    'rules_violated': rules_violated,
                    'description': description,
                    'severity': severity
                })

print(f"Found {len(violations)} violations in the table")

# If we didn't find the expected table format, try a fallback approach
if not table_header_found or len(violations) == 0:
    print("Table header not found or no violations parsed, trying alternative approach")
    # Look for any line that might contain log violations
    pattern = r'"([^"]+)"\s*\|\s*([^|]+)\|\s*([^|]+)\|\s*(\w+)'
    matches = re.findall(pattern, violations_text)
    for match in matches:
        if len(match) == 4:
            violations.append({
                'log_line': match[0],
                'rules_violated': match[1].strip(),
                'description': match[2].strip(),
                'severity': match[3].strip()
            })
    print(f"Found {len(violations)} violations using alternative approach")

return violations

def create_jira_ticket(violation):
"""
Create a Jira ticket for a violation.
"""
priority = SEVERITY_TO_PRIORITY.get(violation['severity'], "Medium")

payload = {
    "fields": {
        "project": {"key": JIRA_PROJECT_KEY},
        "summary": f"Security Violation: {violation['rules_violated']}",
        "description": f"""
Security violation detected:

Log Line: {violation['log_line']}
Rules Violated: {violation['rules_violated']}
Description: {violation['description']}
Severity: {violation['severity']}

Auto-generated by security log analysis.
        """,
        "issuetype": {"name": "Task"},
        "priority": {"name": priority},
        "labels": ["security", "nist-violation"]
    }
}

response = requests.post(
    JIRA_API_ENDPOINT,
    json=payload,
    auth=(JIRA_USERNAME, JIRA_API_TOKEN),
    headers={"Content-Type": "application/json"}
)

if response.status_code == 201:
    return response.json().get('key')
else:
    print(f"Failed to create Jira ticket: {response.status_code} - {response.text}")
    return None
